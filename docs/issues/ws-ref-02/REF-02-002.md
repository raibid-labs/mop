# REF-02-002: gRPC Service - Implement gRPC Server and Handlers

## Context
Implement the AuthService gRPC server with all RPC handlers including unary calls (Login, Logout, ValidateToken, RefreshToken) and server streaming (StreamEvents). Demonstrate realistic authentication patterns that OBI will automatically instrument.

## Requirements
- [ ] Implement AuthService server struct
- [ ] Implement Login RPC with token generation
- [ ] Implement Logout RPC with session cleanup
- [ ] Implement ValidateToken RPC
- [ ] Implement RefreshToken RPC
- [ ] Implement StreamEvents RPC (server streaming)
- [ ] Add in-memory session store (map with mutex)
- [ ] Generate JWT tokens (or simple tokens for demo)
- [ ] Add proper gRPC status codes and error details
- [ ] Implement graceful server shutdown

## Acceptance Criteria
1. All RPC methods implemented and functional
2. Login generates valid tokens and stores sessions
3. Logout removes sessions correctly
4. ValidateToken checks token validity
5. RefreshToken generates new tokens
6. StreamEvents sends events via server stream
7. Error cases return appropriate gRPC status codes
8. Unit tests cover all RPC methods (80%+ coverage)
9. Server starts and handles requests correctly
10. Graceful shutdown works without dropping connections

## Clarifying Questions

**Q1: Should we use real JWT tokens or simple tokens?**
- Context: Complexity vs realism
- Options:
  - A) Simple UUID tokens (easy to understand)
  - B) JWT tokens (realistic but complex)
  - C) Configurable (both options)
- Default: Simple UUID tokens for clarity

**Q2: How long should StreamEvents stream for?**
- Context: Demonstration of streaming behavior
- Options:
  - A) Fixed duration (30 seconds)
  - B) Until client disconnects
  - C) Configurable interval with events
- Default: Periodic events (every 5s) until client disconnects

**Q3: Should we implement real authentication?**
- Context: Security vs simplicity
- Options:
  - A) Mock (any username/password works)
  - B) Simple hardcoded users
  - C) Real bcrypt password hashing
- Default: Simple hardcoded users (focus on gRPC, not auth logic)

## Technical Notes

### Files to Create
```
internal/
├── service/
│   ├── auth_service.go          # AuthService implementation
│   ├── session_store.go         # In-memory sessions
│   └── token_manager.go         # Token generation/validation
└── service/
    └── service_test.go          # Unit tests
cmd/server/
└── main.go                      # Server startup
```

### Service Implementation
```go
// internal/service/auth_service.go
type AuthService struct {
    authv1.UnimplementedAuthServiceServer
    sessions *SessionStore
    tokens   *TokenManager
    logger   *zap.Logger
}

func (s *AuthService) Login(ctx context.Context, req *authv1.LoginRequest) (*authv1.LoginResponse, error) {
    // Validate credentials
    // Generate token
    // Store session
    // Return response
}

func (s *AuthService) StreamEvents(req *authv1.EventsRequest, stream authv1.AuthService_StreamEventsServer) error {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-stream.Context().Done():
            return nil
        case <-ticker.C:
            event := &authv1.Event{
                EventType: "user_activity",
                Timestamp: timestamppb.Now(),
            }
            if err := stream.Send(event); err != nil {
                return err
            }
        }
    }
}
```

### Server Main
```go
// cmd/server/main.go
func main() {
    lis, err := net.Listen("tcp", ":9090")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }

    grpcServer := grpc.NewServer()
    authv1.RegisterAuthServiceServer(grpcServer, service.NewAuthService())

    log.Println("gRPC server listening on :9090")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}
```

### Testing Approach
- Unit tests for each RPC method
- Mock context and streams
- Test error cases and status codes
- Test concurrent requests
- No integration tests yet (separate issue)

### Integration Points
- Uses protobuf from REF-02-001
- Will be called by client in REF-02-003
- Will be enhanced with interceptors in REF-02-004

## Definition of Done
- [ ] All RPC methods implemented
- [ ] Session management working
- [ ] Token generation/validation working
- [ ] Server streaming working
- [ ] Unit tests passing (80%+ coverage)
- [ ] Error handling with proper gRPC status codes
- [ ] Server starts and handles requests
- [ ] golangci-lint passing
- [ ] README updated with RPC documentation
- [ ] Code reviewed
- [ ] PR merged

## Related Issues
- Blocked by: REF-02-001
- Blocks: REF-02-003, REF-02-004
- Related: REF-01-002 (similar handler patterns)

## Labels
`workstream:ws-ref-02`, `priority:critical`, `status:new`, `type:feature`, `protocol:grpc`
