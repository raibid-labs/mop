# REF-01-004: HTTP REST API - Kubernetes Deployment Manifests

## Context
Create Kubernetes manifests to deploy the HTTP REST API service in a cluster with OBI eBPF instrumentation. Include deployment, service, configmap, and resource management for production-like operation.

## Requirements
- [ ] Create Deployment manifest with proper resource limits
- [ ] Create Service manifest (ClusterIP and optional LoadBalancer)
- [ ] Create ConfigMap for application configuration
- [ ] Create ServiceAccount for RBAC (if needed)
- [ ] Add health check probes (liveness, readiness, startup)
- [ ] Configure environment variables for configuration
- [ ] Add labels and annotations for OBI discovery
- [ ] Set resource requests/limits for CPU and memory
- [ ] Configure pod disruption budget
- [ ] Add HorizontalPodAutoscaler (HPA) manifest

## Acceptance Criteria
1. Deployment creates pods successfully
2. Service exposes application correctly
3. Health probes prevent traffic to unhealthy pods
4. ConfigMap values injected as environment variables
5. Resource limits prevent resource exhaustion
6. Labels follow Kubernetes best practices
7. OBI annotations present for protocol detection
8. HPA scales based on CPU utilization
9. `kubectl apply -f` deploys without errors
10. Application accessible via service endpoint

## Clarifying Questions

**Q1: Should we use a Deployment or StatefulSet?**
- Context: HTTP API is typically stateless
- Options:
  - A) Deployment (stateless, recommended)
  - B) StatefulSet (stateful, unnecessary here)
- Default: Deployment (API is stateless)

**Q2: What service type should we use?**
- Context: Internal vs external access
- Options:
  - A) ClusterIP only (internal)
  - B) LoadBalancer (external)
  - C) Both (ClusterIP + optional LoadBalancer)
- Default: ClusterIP with optional LoadBalancer comment

**Q3: How should configuration be managed?**
- Context: Configuration vs secrets
- Options:
  - A) ConfigMap only
  - B) ConfigMap + Secrets
  - C) Environment variables only
- Default: ConfigMap (no secrets needed for this example)

**Q4: What resource limits are appropriate?**
- Context: Balance between safety and efficiency
- Options:
  - A) Minimal (100m CPU, 128Mi memory)
  - B) Standard (250m CPU, 256Mi memory)
  - C) Generous (500m CPU, 512Mi memory)
- Default: Standard (good for demo + load testing)

## Technical Notes

### Files to Create
```
deployments/examples/01-http-api/
├── deployment.yaml              # Main deployment
├── service.yaml                 # Service definition
├── configmap.yaml               # Configuration
├── hpa.yaml                     # Horizontal Pod Autoscaler
└── kustomization.yaml           # Kustomize configuration (optional)
```

### Deployment Manifest Structure
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: http-api
  labels:
    app: http-api
    protocol: http
    example: product-catalog
spec:
  replicas: 3
  selector:
    matchLabels:
      app: http-api
  template:
    metadata:
      labels:
        app: http-api
        protocol: http
      annotations:
        obi.io/enabled: "true"         # OBI discovery
        obi.io/protocol: "http"        # Protocol hint
        obi.io/port: "8080"            # Port hint
    spec:
      containers:
      - name: http-api
        image: http-api:latest
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        env:
        - name: PORT
          value: "8080"
        - name: LOG_LEVEL
          value: "info"
        - name: RATE_LIMIT_RPS
          value: "100"
        envFrom:
        - configMapRef:
            name: http-api-config
        resources:
          requests:
            cpu: 250m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 2
        startupProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 0
          periodSeconds: 2
          timeoutSeconds: 3
          failureThreshold: 30
```

### Service Manifest
```yaml
apiVersion: v1
kind: Service
metadata:
  name: http-api
  labels:
    app: http-api
spec:
  type: ClusterIP
  selector:
    app: http-api
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
```

### ConfigMap
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: http-api-config
data:
  APP_NAME: "product-catalog"
  ENVIRONMENT: "demo"
  LOG_FORMAT: "json"
  ENABLE_METRICS: "true"
```

### HorizontalPodAutoscaler
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: http-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: http-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

### OBI Annotations
Key annotations for OBI automatic discovery:
- `obi.io/enabled: "true"` - Enable OBI for this pod
- `obi.io/protocol: "http"` - Hint protocol type
- `obi.io/port: "8080"` - Application port

### Testing Approach
```bash
# Validate manifests
kubectl apply --dry-run=client -f deployments/examples/01-http-api/

# Apply to cluster
kubectl apply -f deployments/examples/01-http-api/

# Verify deployment
kubectl get pods -l app=http-api
kubectl get svc http-api
kubectl logs -l app=http-api

# Test health endpoint
kubectl port-forward svc/http-api 8080:80
curl http://localhost:8080/health

# Verify OBI is instrumenting
kubectl logs -l app=obi-agent | grep http-api
```

### Integration Points
- Docker image from REF-01-001
- Application from REF-01-002, REF-01-003
- OBI agent discovers via annotations
- Load generators (REF-06-001) target this service
- Grafana dashboard (REF-01-006) queries these pods

## Definition of Done
- [ ] All Kubernetes manifests created and valid
- [ ] Deployment creates 3 replicas successfully
- [ ] Service routes traffic to pods correctly
- [ ] Health probes working (liveness, readiness, startup)
- [ ] ConfigMap values injected into pods
- [ ] Resource limits prevent runaway resource usage
- [ ] OBI annotations correct and documented
- [ ] HPA scales pods under load
- [ ] `kubectl apply -f` deploys without errors
- [ ] Manual testing confirms service accessibility
- [ ] README updated with deployment instructions
- [ ] Tested in local Kubernetes (kind/minikube)
- [ ] Code reviewed for Kubernetes best practices
- [ ] PR merged to main branch

## Related Issues
- Blocked by: REF-01-001 (needs Docker image)
- Blocked by: REF-01-002 (needs application code)
- Blocks: REF-01-005 (integration tests use deployment)
- Blocks: REF-06-001 (load generator needs deployed service)
- Related: All other deployment issues (REF-02-005, REF-03-005, etc.)

## Labels
`workstream:ws-ref-01`, `priority:high`, `status:new`, `type:deployment`, `protocol:http`
