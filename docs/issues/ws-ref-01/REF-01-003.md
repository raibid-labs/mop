# REF-01-003: HTTP REST API - Add Middleware

## Context
Implement middleware layers for logging, error handling, rate limiting, and CORS. These middleware components will demonstrate how OBI captures HTTP interactions at the protocol level, including middleware processing time.

## Requirements
- [ ] Implement request logging middleware (structured logs with zap)
- [ ] Implement error recovery middleware (panic handling)
- [ ] Implement rate limiting middleware (per-IP limits)
- [ ] Implement CORS middleware for cross-origin requests
- [ ] Implement request ID middleware (trace propagation)
- [ ] Implement timeout middleware (prevent long-running requests)
- [ ] Configure middleware order correctly
- [ ] Add metrics collection middleware (request counter, duration)
- [ ] Log HTTP method, path, status, duration, error details

## Acceptance Criteria
1. All requests logged with structured fields
2. Panics recovered and return 500 without crashing server
3. Rate limiting enforces limits (e.g., 100 req/min per IP)
4. CORS headers added correctly for cross-origin requests
5. Every request has a unique request ID in response headers
6. Long requests timeout after configured duration (30s default)
7. Middleware order is logical (logging first, recovery last)
8. Unit tests verify each middleware behavior
9. Integration tests show middleware chain works correctly
10. Logs are JSON formatted for OBI ingestion

## Clarifying Questions

**Q1: What rate limiting strategy should we use?**
- Context: Different strategies have different characteristics
- Options:
  - A) Token bucket (smooth rate)
  - B) Fixed window (simple, can burst)
  - C) Sliding window (accurate, complex)
- Default: Token bucket via `golang.org/x/time/rate` (Go standard)

**Q2: Should we use custom middleware or third-party libraries?**
- Context: Learning vs production-ready trade-off
- Options:
  - A) Custom implementation (educational)
  - B) Gin contrib middleware (battle-tested)
  - C) Mix of both
- Default: Mix - custom for core logic, contrib for CORS/recovery

**Q3: How detailed should request logging be?**
- Context: Log volume vs debugging value
- Options:
  - A) Minimal (method, path, status, duration)
  - B) Standard (+ request_id, user_agent, ip)
  - C) Verbose (+ headers, body)
- Default: Standard (good balance for observability)

**Q4: Should rate limiting be configurable?**
- Context: Testing needs vs production needs
- Options:
  - A) Hard-coded limits
  - B) Environment variables
  - C) Configuration file
- Default: Environment variables (12-factor app)

## Technical Notes

### Files to Create
```
internal/middleware/
├── logger.go                    # Structured logging
├── recovery.go                  # Panic recovery
├── ratelimit.go                 # Rate limiting
├── cors.go                      # CORS headers
├── requestid.go                 # Request ID generation
├── timeout.go                   # Request timeout
└── metrics.go                   # Basic metrics collection
internal/middleware/
└── middleware_test.go           # Unit tests
```

### Middleware Signatures
```go
// middleware/logger.go
func Logger(logger *zap.Logger) gin.HandlerFunc

// middleware/recovery.go
func Recovery(logger *zap.Logger) gin.HandlerFunc

// middleware/ratelimit.go
func RateLimit(rps int) gin.HandlerFunc

// middleware/cors.go
func CORS() gin.HandlerFunc

// middleware/requestid.go
func RequestID() gin.HandlerFunc

// middleware/timeout.go
func Timeout(duration time.Duration) gin.HandlerFunc

// middleware/metrics.go
func Metrics() gin.HandlerFunc
```

### Middleware Order (main.go)
```go
r := gin.New()

// Order matters!
r.Use(middleware.RequestID())        // 1. Generate request ID first
r.Use(middleware.Logger(logger))     // 2. Log everything
r.Use(middleware.Recovery(logger))   // 3. Recover panics
r.Use(middleware.CORS())             // 4. Handle CORS
r.Use(middleware.Timeout(30*time.Second)) // 5. Set timeouts
r.Use(middleware.RateLimit(100))     // 6. Rate limit
r.Use(middleware.Metrics())          // 7. Collect metrics

// Register routes...
```

### Structured Logging Format
```json
{
  "level": "info",
  "ts": "2024-01-15T10:30:00Z",
  "msg": "http request",
  "request_id": "abc123",
  "method": "GET",
  "path": "/products/123",
  "status": 200,
  "duration_ms": 45,
  "ip": "192.168.1.1",
  "user_agent": "curl/7.64.1",
  "error": null
}
```

### Rate Limiting Implementation
```go
// Use golang.org/x/time/rate
import "golang.org/x/time/rate"

var limiters = sync.Map{} // IP -> *rate.Limiter

func RateLimit(rps int) gin.HandlerFunc {
    return func(c *gin.Context) {
        ip := c.ClientIP()
        limiter := getLimiter(ip, rps)

        if !limiter.Allow() {
            c.JSON(429, gin.H{"error": "rate limit exceeded"})
            c.Abort()
            return
        }
        c.Next()
    }
}
```

### Testing Approach
```go
// Unit tests per middleware
func TestLogger(t *testing.T) {
    // Test that logger writes expected fields
}

func TestRateLimit(t *testing.T) {
    // Test that rate limit enforces correctly
    // Make rapid requests, verify 429 response
}

func TestRecovery(t *testing.T) {
    // Trigger panic, verify 500 response
    // Verify server still running
}

// Integration test
func TestMiddlewareChain(t *testing.T) {
    // Start server with all middleware
    // Make requests, verify all middleware executed
    // Check logs contain request_id, duration, etc.
}
```

### Dependencies
- `go.uber.org/zap` - Structured logging
- `golang.org/x/time/rate` - Rate limiting
- `github.com/google/uuid` - Request ID generation

### Integration Points
- Uses handlers from REF-01-002
- Logs consumed by OBI
- Request IDs used for trace correlation
- Metrics exposed for Grafana (REF-01-006)

## Definition of Done
- [ ] All middleware implemented with proper logic
- [ ] Middleware correctly ordered in router setup
- [ ] Structured logging outputs JSON format
- [ ] Rate limiting enforces limits correctly
- [ ] Panic recovery prevents crashes
- [ ] Unit tests for each middleware (80%+ coverage)
- [ ] Integration tests verify middleware chain
- [ ] All tests passing locally
- [ ] golangci-lint passing
- [ ] Manual testing confirms middleware behavior
- [ ] README updated with middleware documentation
- [ ] Environment variables documented
- [ ] Code reviewed for security and performance
- [ ] PR merged to main branch

## Related Issues
- Blocked by: REF-01-002 (needs handlers to wrap)
- Blocks: REF-01-005 (tests use middleware)
- Related: REF-01-006 (metrics middleware feeds Grafana)
- Related: REF-02-004 (gRPC interceptors - similar concept)

## Labels
`workstream:ws-ref-01`, `priority:high`, `status:new`, `type:feature`, `protocol:http`
