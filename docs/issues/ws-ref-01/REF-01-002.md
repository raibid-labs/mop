# REF-01-002: HTTP REST API - Implement HTTP Handlers

## Context
Implement the core HTTP handlers for the product catalog service using Gin framework. Create CRUD operations and testing endpoints that will be automatically instrumented by OBI eBPF without any SDK or library changes.

## Requirements
- [ ] Implement in-memory product store (map with mutex)
- [ ] Create GET /products handler with pagination
- [ ] Create GET /products/:id handler
- [ ] Create POST /products handler
- [ ] Create PUT /products/:id handler
- [ ] Create DELETE /products/:id handler
- [ ] Create GET /search handler with query parameters
- [ ] Create GET /health handler for liveness/readiness probes
- [ ] Create GET /slow handler (simulates 1-3s latency)
- [ ] Create GET /error handler (returns 500 errors)
- [ ] Add proper HTTP status codes and error responses
- [ ] Include request validation

## Acceptance Criteria
1. All CRUD endpoints functional and tested
2. Pagination works correctly (limit, offset parameters)
3. Search filters products by name/description
4. Health endpoint returns 200 with status JSON
5. Slow endpoint consistently takes 1-3 seconds
6. Error endpoint returns 500 with error details
7. Input validation returns 400 for invalid requests
8. All endpoints return proper JSON responses
9. Unit tests cover happy path and error cases (80%+ coverage)
10. Integration tests verify end-to-end flows

## Clarifying Questions

**Q1: Should we persist data or use in-memory storage?**
- Context: Simplicity vs realism trade-off
- Options:
  - A) In-memory map (simple, no dependencies)
  - B) SQLite (persistent, still simple)
  - C) PostgreSQL (realistic, complex)
- Default: In-memory map for simplicity (SQL example is separate in WS-REF-03)

**Q2: How should pagination work?**
- Context: Different pagination strategies available
- Options:
  - A) Offset-based (?limit=10&offset=20)
  - B) Cursor-based (?cursor=abc123)
  - C) Page-based (?page=2&per_page=10)
- Default: Offset-based (simplest, most common)

**Q3: Should the slow endpoint have configurable latency?**
- Context: Load testing might need varying delays
- Options:
  - A) Fixed 2s delay
  - B) Random 1-3s delay
  - C) Configurable via query param (?delay=2000)
- Default: Random 1-3s for realistic variability

**Q4: What should search support?**
- Context: Complexity of search functionality
- Options:
  - A) Exact match only
  - B) Substring match (case-insensitive)
  - C) Full-text search
- Default: Substring match (good balance)

## Technical Notes

### Files to Create
```
internal/
├── models/
│   └── product.go               # Product struct, validation
├── handlers/
│   ├── products.go              # CRUD handlers
│   ├── health.go                # Health check
│   └── testing.go               # Slow/error endpoints
└── store/
    └── memory.go                # In-memory storage with sync.RWMutex
cmd/server/
└── main.go                      # Router setup, handler registration
```

### Product Model
```go
type Product struct {
    ID          string    `json:"id"`
    Name        string    `json:"name" binding:"required,min=3,max=100"`
    Description string    `json:"description"`
    Price       float64   `json:"price" binding:"required,gt=0"`
    Stock       int       `json:"stock" binding:"gte=0"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}
```

### Handler Signatures
```go
// handlers/products.go
func ListProducts(c *gin.Context)      // GET /products
func GetProduct(c *gin.Context)        // GET /products/:id
func CreateProduct(c *gin.Context)     // POST /products
func UpdateProduct(c *gin.Context)     // PUT /products/:id
func DeleteProduct(c *gin.Context)     // DELETE /products/:id
func SearchProducts(c *gin.Context)    // GET /search

// handlers/health.go
func HealthCheck(c *gin.Context)       // GET /health

// handlers/testing.go
func SlowEndpoint(c *gin.Context)      // GET /slow
func ErrorEndpoint(c *gin.Context)     // GET /error
```

### Router Setup (main.go)
```go
r := gin.Default()

// Product endpoints
products := r.Group("/products")
{
    products.GET("", handlers.ListProducts)
    products.GET("/:id", handlers.GetProduct)
    products.POST("", handlers.CreateProduct)
    products.PUT("/:id", handlers.UpdateProduct)
    products.DELETE("/:id", handlers.DeleteProduct)
}

// Other endpoints
r.GET("/search", handlers.SearchProducts)
r.GET("/health", handlers.HealthCheck)
r.GET("/slow", handlers.SlowEndpoint)
r.GET("/error", handlers.ErrorEndpoint)
```

### Testing Approach
```go
// Unit tests (handlers_test.go)
- Test each handler with httptest.ResponseRecorder
- Mock the store interface
- Verify status codes, response bodies
- Test validation failures

// Integration tests (tests/integration_test.go)
- Start server with test data
- Make real HTTP requests
- Verify end-to-end behavior
- Test concurrent requests
```

### Dependencies
- `github.com/gin-gonic/gin` - HTTP framework
- `github.com/google/uuid` - Generate product IDs
- `github.com/stretchr/testify` - Testing assertions

### Integration Points
- Uses project structure from REF-01-001
- Will be enhanced with middleware in REF-01-003
- Will be deployed in REF-01-004

## Definition of Done
- [ ] All handlers implemented with proper error handling
- [ ] In-memory store with thread-safe operations
- [ ] Product model with validation tags
- [ ] Unit tests for all handlers (80%+ coverage)
- [ ] Integration tests for end-to-end flows
- [ ] All tests passing locally
- [ ] golangci-lint passing
- [ ] Manual testing confirms all endpoints work
- [ ] README updated with API endpoint documentation
- [ ] Code reviewed for best practices
- [ ] PR merged to main branch

## Related Issues
- Blocked by: REF-01-001 (needs project structure)
- Blocks: REF-01-003 (middleware wraps these handlers)
- Blocks: REF-01-005 (integration tests expand on these)
- Related: REF-03-004 (SQL app has similar handlers)

## Labels
`workstream:ws-ref-01`, `priority:critical`, `status:new`, `type:feature`, `protocol:http`
